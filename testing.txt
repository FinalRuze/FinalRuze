$source = @"
using System;
using System.Runtime.InteropServices;
using System.Threading;

public static class Win32
{
    [DllImport("user32.dll")]
    static extern int GetSystemMetrics(int smIndex);

    [DllImport("user32.dll")]
    static extern IntPtr GetDC(IntPtr hWnd);

    [DllImport("gdi32.dll")]
    static extern bool StretchBlt(IntPtr hdcDest, int nXOriginDest, int nYOriginDest, int nWidthDest, int nHeightDest, IntPtr hdcSrc, int nXOriginSrc, int nYOriginSrc, int nWidthSrc, int nHeightSrc, int dwRop);

    [DllImport("user32.dll", SetLastError = true)]
    static extern bool SetProcessDPIAware();

    [DllImport("gdi32.dll")]
    static extern IntPtr CreatePen(int fnPenStyle, int nWidth, uint crColor);

    [DllImport("gdi32.dll")]
    static extern IntPtr SelectObject(IntPtr hdc, IntPtr hgdiobj);

    [DllImport("gdi32.dll")]
    static extern bool Rectangle(IntPtr hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect);

    [DllImport("gdi32.dll")]
    static extern bool Polygon(IntPtr hdc, int[] points, int nCount);

    [DllImport("gdi32.dll")]
    static extern bool Ellipse(IntPtr hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect);

    [DllImport("gdi32.dll")]
    static extern bool RoundRect(IntPtr hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nWidth, int nHeight);

    [DllImport("gdi32.dll")]
    static extern bool BitBlt(IntPtr hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, IntPtr hdcSrc, int nXSrc, int nYSrc, uint dwRop);

    [DllImport("gdi32.dll")]
    static extern int SetROP2(IntPtr hdc, int fnDrawMode);

    public static void ReversePIP()
    {
        SetProcessDPIAware();
        int cx = GetSystemMetrics(0);
        int cy = GetSystemMetrics(1);

        while (true)
        {
            Thread.Sleep(800);
            IntPtr hdc = GetDC(IntPtr.Zero);

            // Original effect - StretchBlt
            StretchBlt(hdc, 0, 0, cx, cy, hdc, 50, 50, cx - 100, cy - 100, 0x00CC0020);

            // Additional effect 1 - Drawing rectangles
            IntPtr pen = CreatePen(0, 5, 0x000000); // Black color pen
            IntPtr oldPen = SelectObject(hdc, pen);

            Rectangle(hdc, 100, 100, cx - 100, cy - 100);
            Rectangle(hdc, 200, 200, cx - 200, cy - 200);

            SelectObject(hdc, oldPen);

            // Additional effect 2 - Drawing multiple hexagons to fill the screen
            int hexagonSize = 100;
            int hexagonMargin = 20;
            int hexagonRowCount = (cy - 2 * hexagonMargin) / (hexagonSize + hexagonMargin);
            int hexagonColumnCount = (cx - 2 * hexagonMargin) / (hexagonSize + hexagonMargin);
            int totalHexagons = hexagonRowCount * hexagonColumnCount;

            int[] hexagonXPositions = new int[totalHexagons];
            int[] hexagonYPositions = new int[totalHexagons];

            int startX = hexagonMargin;
            int startY = hexagonMargin;

            for (int i = 0; i < totalHexagons; i++)
            {
                int row = i / hexagonColumnCount;
                int column = i % hexagonColumnCount;

                int hexagonX = startX + column * (hexagonSize + hexagonMargin);
                int hexagonY = startY + row * (hexagonSize + hexagonMargin);

                hexagonXPositions[i] = hexagonX;
                hexagonYPositions[i] = hexagonY;

                int[] hexagonPoints = new int[]
                {
                    hexagonX + hexagonSize / 2, hexagonY,
                    hexagonX + hexagonSize, hexagonY + hexagonSize / 3,
                    hexagonX + hexagonSize, hexagonY + 2 * hexagonSize / 3,
                    hexagonX + hexagonSize / 2, hexagonY + hexagonSize,
                    hexagonX, hexagonY + 2 * hexagonSize / 3,
                    hexagonX, hexagonY + hexagonSize / 3
                };
                Polygon(hdc, hexagonPoints, hexagonPoints.Length / 2);
            }

            // Additional effect 3 - Drawing ellipses
            int ellipseSize = 100;
            int ellipseMargin = 50;
            int ellipseRowCount = (cy - 2 * ellipseMargin) / (ellipseSize + ellipseMargin);
            int ellipseColumnCount = (cx - 2 * ellipseMargin) / (ellipseSize + ellipseMargin);

            for (int row = 0; row < ellipseRowCount; row++)
            {
                for (int column = 0; column < ellipseColumnCount; column++)
                {
                    int ellipseX = ellipseMargin + column * (ellipseSize + ellipseMargin);
                    int ellipseY = ellipseMargin + row * (ellipseSize + ellipseMargin);

                    Ellipse(hdc, ellipseX, ellipseY, ellipseX + ellipseSize, ellipseY + ellipseSize);
                }
            }

            // Additional effect 4 - Drawing rounded rectangles
            int roundedRectWidth = 200;
            int roundedRectHeight = 100;
            int roundedRectMargin = 50;
            int roundedRectRowCount = (cy - 2 * roundedRectMargin) / (roundedRectHeight + roundedRectMargin);
            int roundedRectColumnCount = (cx - 2 * roundedRectMargin) / (roundedRectWidth + roundedRectMargin);

            for (int row = 0; row < roundedRectRowCount; row++)
            {
                for (int column = 0; column < roundedRectColumnCount; column++)
                {
                    int roundedRectX = roundedRectMargin + column * (roundedRectWidth + roundedRectMargin);
                    int roundedRectY = roundedRectMargin + row * (roundedRectHeight + roundedRectMargin);

                    RoundRect(hdc, roundedRectX, roundedRectY, roundedRectX + roundedRectWidth, roundedRectY + roundedRectHeight, 20, 20);
                }
            }

            // Additional effect 5 - Inverting colors
            BitBlt(hdc, 0, 0, cx, cy, hdc, 0, 0, 0x00550009);

            // Additional effect 6 - Changing drawing mode
            int oldDrawMode = SetROP2(hdc, 7);
            
            // Additional effect 7 - Drawing lines
            int lineMargin = 50;
            int lineCount = (cy - 2 * lineMargin) / 50;
            int lineSpacing = (cx - 2 * lineMargin) / lineCount;

            for (int i = 0; i < lineCount; i++)
            {
                int lineX = lineMargin + i * lineSpacing;
                int lineY1 = lineMargin;
                int lineY2 = cy - lineMargin;

                IntPtr linePen = CreatePen(0, 2, (uint)(0xFF0000 * (i + 1) / lineCount)); // Varying color for each line
                IntPtr oldLinePen = SelectObject(hdc, linePen);

                Rectangle(hdc, lineX, lineY1, lineX + 2, lineY2);

                SelectObject(hdc, oldLinePen);
            }

            // Additional effect 8 - Drawing text
            string text = "GDI Effects";
            int fontSize = 36;
            IntPtr font = CreateFont(-fontSize, 0, 0, 0, 700, 0, 0, 0, 0, 0, 0, 0, 0, "Arial");
            IntPtr oldFont = SelectObject(hdc, font);

            SetTextColor(hdc, 0x0000FF); // Blue color for text
            SetBkMode(hdc, 1); // Transparent background for text

            int textX = (cx - text.Length * fontSize) / 2;
            int textY = (cy - fontSize) / 2;

            TextOut(hdc, textX, textY, text, text.Length);

            SelectObject(hdc, oldFont);

            // Additional effect 9 - Drawing curves
            int curveMargin = 50;
            int curveCount = (cy - 2 * curveMargin) / 50;
            int curveSpacing = (cx - 2 * curveMargin) / curveCount;

            for (int i = 0; i < curveCount; i++)
            {
                int curveX = curveMargin + i * curveSpacing;
                int curveY = curveMargin;

                int curveWidth = curveSpacing / 2;
                int curveHeight = cy - 2 * curveMargin;

                Arc(hdc, curveX, curveY, curveX + curveWidth, curveY + curveHeight, 0, 0, 0, 0);
            }

            // Additional effect 10 - Drawing images
            IntPtr image = LoadImage(IntPtr.Zero, "path_to_image.bmp", 0, 0, 0x00000010 | 0x00000020);
            IntPtr oldImage = SelectObject(hdc, image);

            int imageX = cx / 2;
            int imageY = cy / 2;

            int imageWidth = 200;
            int imageHeight = 200;

            StretchBlt(hdc, imageX - imageWidth / 2, imageY - imageHeight / 2, imageWidth, imageHeight, hdc, 0, 0, cx, cy, 0x00CC0020);

            SelectObject(hdc, oldImage);

            // Additional effect 11 - Filling the screen with a pattern
            IntPtr patternBrush = CreatePatternBrush(image);
            IntPtr oldBrush = SelectObject(hdc, patternBrush);

            Rectangle(hdc, 0, 0, cx, cy);

            SelectObject(hdc, oldBrush);

            // Additional effect 12 - Drawing Bezier curves
            int bezierMargin = 50;
            int bezierCount = (cy - 2 * bezierMargin) / 100;
            int bezierSpacing = (cx - 2 * bezierMargin) / bezierCount;

            for (int i = 0; i < bezierCount; i++)
            {
                int bezierX1 = bezierMargin + i * bezierSpacing;
                int bezierY1 = bezierMargin;
                int bezierX2 = bezierX1 + bezierSpacing / 2;
                int bezierY2 = cy - bezierMargin;
                int bezierX3 = bezierX1 + bezierSpacing;
                int bezierY3 = bezierMargin;

                PolyBezier(hdc, new POINT[]
                {
                    new POINT(bezierX1, bezierY1),
                    new POINT(bezierX2, bezierY2),
                    new POINT(bezierX3, bezierY3)
                }, 3);
            }

            ReleaseDC(IntPtr.Zero, hdc);
        }
    }
}
"@
Add-Type -TypeDefinition $source -Language CSharp
[Win32]::ReversePIP()
