$source = @"
using System;
using System.Runtime.InteropServices;
using System.Threading;

public static class Win32
{
    [DllImport("user32.dll")]
    static extern int GetSystemMetrics(int smIndex);

    [DllImport("user32.dll")]
    static extern IntPtr GetDC(IntPtr hWnd);

    [DllImport("gdi32.dll")]
    static extern bool BitBlt(IntPtr hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, IntPtr hdcSrc, int nXSrc, int nYSrc, int dwRop);

    [DllImport("user32.dll", SetLastError = true)]
    static extern bool SetProcessDPIAware();

    public static void PIP()
    {
        SetProcessDPIAware();
        int cx = GetSystemMetrics(0);
        int cy = GetSystemMetrics(1);

        int alpha = 0;

        while (alpha < 255)
        {
            alpha += 5; // Adjust the increment value to control the speed of the effect.
            Thread.Sleep(100); // Adjust the sleep duration to control the speed of the effect.

            IntPtr hdc = GetDC(IntPtr.Zero);
            IntPtr memdc = GetDC(IntPtr.Zero);

            // Create a compatible DC and a bitmap to hold the final image.
            IntPtr compatDc = Win32.CreateCompatibleDC(hdc);
            IntPtr bitmap = Win32.CreateCompatibleBitmap(hdc, cx, cy);
            IntPtr oldBitmap = Win32.SelectObject(compatDc, bitmap);

            // Copy the screen contents to the compatible DC.
            Win32.BitBlt(compatDc, 0, 0, cx, cy, hdc, 0, 0, 0x00CC0020);

            // Apply the transparency effect by setting the alpha value of each pixel.
            Win32.AlphaBlend(compatDc, 0, 0, cx, cy, memdc, 0, 0, cx, cy, new Win32.BLENDFUNCTION
            {
                BlendOp = Win32.AC_SRC_OVER,
                BlendFlags = 0,
                SourceConstantAlpha = (byte)alpha,
                AlphaFormat = Win32.AC_SRC_ALPHA
            });

            // Draw the modified image to the screen.
            Win32.BitBlt(hdc, 0, 0, cx, cy, compatDc, 0, 0, 0x00CC0020);

            // Clean up the resources.
            Win32.SelectObject(compatDc, oldBitmap);
            Win32.DeleteObject(bitmap);
            Win32.DeleteDC(compatDc);
            Win32.ReleaseDC(IntPtr.Zero, hdc);
        }
    }

    // Structures and constants needed for the GDI functions.
    [StructLayout(LayoutKind.Sequential)]
    public struct BLENDFUNCTION
    {
        public byte BlendOp;
        public byte BlendFlags;
        public byte SourceConstantAlpha;
        public byte AlphaFormat;
    }

    const byte AC_SRC_OVER = 0x00;
    const byte AC_SRC_ALPHA = 0x01;

    [DllImport("gdi32.dll", SetLastError = true)]
    static extern IntPtr CreateCompatibleDC(IntPtr hdc);

    [DllImport("gdi32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    static extern bool DeleteDC(IntPtr hdc);

    [DllImport("gdi32.dll", SetLastError = true)]
    static extern IntPtr CreateCompatibleBitmap(IntPtr hdc, int nWidth, int nHeight);

    [DllImport("gdi32.dll", SetLastError = true)]
    static extern IntPtr SelectObject(IntPtr hdc, IntPtr hgdiobj);

    [DllImport("gdi32.dll", ExactSpelling = true, SetLastError = true)]
    static extern bool BitBlt(IntPtr hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, IntPtr hdcSrc, int nXSrc, int nYSrc, int dwRop);

    [DllImport("gdi32.dll", SetLastError = true, ExactSpelling = true)]
    static extern bool AlphaBlend(IntPtr hdcDest, int nXOriginDest, int nYOriginDest, int nWidthDest, int nHeightDest, IntPtr hdcSrc, int nXOriginSrc, int nYOriginSrc, int nWidthSrc, int nHeightSrc, BLENDFUNCTION blendFunction);

    [DllImport("user32.dll")]
    static extern IntPtr GetDesktopWindow();

    [DllImport("user32.dll")]
    static extern IntPtr ReleaseDC(IntPtr hWnd, IntPtr hDc);
}

"@

Add-Type -TypeDefinition $source -Language CSharp
[Win32]::PIP()
