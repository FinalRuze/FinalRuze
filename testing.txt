$source = @"
using System;
using System.Runtime.InteropServices;
using System.Threading;

public static class Win32
{
    [DllImport("user32.dll")]
    static extern int GetSystemMetrics(int smIndex);

    [DllImport("user32.dll")]
    static extern IntPtr GetDC(IntPtr hWnd);

    [DllImport("gdi32.dll")]
    static extern bool StretchBlt(IntPtr hdcDest, int nXOriginDest, int nYOriginDest, int nWidthDest, int nHeightDest, IntPtr hdcSrc, int nXOriginSrc, int nYOriginSrc, int nWidthSrc, int nHeightSrc, int dwRop);

    [DllImport("user32.dll", SetLastError = true)]
    static extern bool SetProcessDPIAware();

    [DllImport("gdi32.dll")]
    static extern IntPtr CreatePen(int fnPenStyle, int nWidth, uint crColor);

    [DllImport("gdi32.dll")]
    static extern IntPtr SelectObject(IntPtr hdc, IntPtr hgdiobj);

    [DllImport("gdi32.dll")]
    static extern bool Rectangle(IntPtr hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect);

    [DllImport("gdi32.dll")]
    static extern bool Polygon(IntPtr hdc, int[] points, int nCount);

    [DllImport("gdi32.dll")]
    static extern bool Ellipse(IntPtr hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect);

    [DllImport("gdi32.dll")]
    static extern bool RoundRect(IntPtr hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nWidth, int nHeight);

    [DllImport("gdi32.dll")]
    static extern bool BitBlt(IntPtr hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, IntPtr hdcSrc, int nXSrc, int nYSrc, uint dwRop);

    [DllImport("gdi32.dll")]
    static extern bool PatBlt(IntPtr hdc, int nXLeft, int nYLeft, int nWidth, int nHeight, uint dwRop);

    public static void ReversePIP()
    {
        SetProcessDPIAware();
        int cx = GetSystemMetrics(0);
        int cy = GetSystemMetrics(1);

        while (true)
        {
            Thread.Sleep(800);
            IntPtr hdc = GetDC(IntPtr.Zero);

            // Original effect - StretchBlt
            StretchBlt(hdc, 0, 0, cx, cy, hdc, 50, 50, cx - 100, cy - 100, 0x00CC0020);

            // Additional effect 1 - Drawing rectangles
            IntPtr pen = CreatePen(0, 5, 0x000000); // Black color pen
            IntPtr oldPen = SelectObject(hdc, pen);

            Rectangle(hdc, 100, 100, cx - 100, cy - 100);
            Rectangle(hdc, 200, 200, cx - 200, cy - 200);

            SelectObject(hdc, oldPen);

            // Additional effect 2 - Drawing multiple hexagons to fill the screen
            int hexagonSize = 100;
            int hexagonMargin = 20;
            int hexagonRowCount = (cy - 2 * hexagonMargin) / (hexagonSize + hexagonMargin);
            int hexagonColumnCount = (cx - 2 * hexagonMargin) / (hexagonSize + hexagonMargin);
            int totalHexagons = hexagonRowCount * hexagonColumnCount;

            int[] hexagonXPositions = new int[totalHexagons];
            int[] hexagonYPositions = new int[totalHexagons];

            int startX = hexagonMargin;
            int startY = hexagonMargin;

            for (int i = 0; i < totalHexagons; i++)
            {
                int row = i / hexagonColumnCount;
                int column = i % hexagonColumnCount;

                int hexagonX = startX + column * (hexagonSize + hexagonMargin);
                int hexagonY = startY + row * (hexagonSize + hexagonMargin);

                hexagonXPositions[i] = hexagonX;
                hexagonYPositions[i] = hexagonY;

                int[] hexagonPoints = new int[]
                {
                    hexagonX + hexagonSize / 2, hexagonY,
                    hexagonX + hexagonSize, hexagonY + hexagonSize / 3,
                    hexagonX + hexagonSize, hexagonY + 2 * hexagonSize / 3,
                    hexagonX + hexagonSize / 2, hexagonY + hexagonSize,
                    hexagonX, hexagonY + 2 * hexagonSize / 3,
                    hexagonX, hexagonY + hexagonSize / 3
                };
                Polygon(hdc, hexagonPoints, hexagonPoints.Length / 2);
            }

            // Additional effect 3 - Drawing ellipses
            int ellipseSize = 100;
            int ellipseMargin = 50;
            int ellipseRowCount = (cy - 2 * ellipseMargin) / (ellipseSize + ellipseMargin);
            int ellipseColumnCount = (cx - 2 * ellipseMargin) / (ellipseSize + ellipseMargin);

            for (int row = 0; row < ellipseRowCount; row++)
            {
                for (int column = 0; column < ellipseColumnCount; column++)
                {
                    int ellipseX = ellipseMargin + column * (ellipseSize + ellipseMargin);
                    int ellipseY = ellipseMargin + row * (ellipseSize + ellipseMargin);

                    Ellipse(hdc, ellipseX, ellipseY, ellipseX + ellipseSize, ellipseY + ellipseSize);
                }
            }

            // Additional effect 4 - Drawing rounded rectangles
            int roundedRectWidth = 200;
            int roundedRectHeight = 100;
            int roundedRectMargin = 50;
            int roundedRectRowCount = (cy - 2 * roundedRectMargin) / (roundedRectHeight + roundedRectMargin);
            int roundedRectColumnCount = (cx - 2 * roundedRectMargin) / (roundedRectWidth + roundedRectMargin);

            for (int row = 0; row < roundedRectRowCount; row++)
            {
                for (int column = 0; column < roundedRectColumnCount; column++)
                {
                    int roundedRectX = roundedRectMargin + column * (roundedRectWidth + roundedRectMargin);
                    int roundedRectY = roundedRectMargin + row * (roundedRectHeight + roundedRectMargin);

                    RoundRect(hdc, roundedRectX, roundedRectY, roundedRectX + roundedRectWidth, roundedRectY + roundedRectHeight, 20, 20);
                }
            }

            // Additional effect 5 - Inverting colors
            BitBlt(hdc, 0, 0, cx, cy, hdc, 0, 0, 0x00550009);

            // Additional effect 6 - Clearing a portion of the screen with a solid color
            int clearX = cx / 4;
            int clearY = cy / 4;
            int clearWidth = cx / 2;
            int clearHeight = cy / 2;

            PatBlt(hdc, clearX, clearY, clearWidth, clearHeight, 0x00FA0089); // Solid light blue color

            // Additional effect 7 - Drawing a gradient background
            uint[] gradientColors = new uint[] { 0x0000FF, 0x00FFFF }; // Blue to cyan gradient
            int gradientSteps = 50;

            for (int i = 0; i < gradientSteps; i++)
            {
                uint color = InterpolateColor(gradientColors[0], gradientColors[1], (float)i / (gradientSteps - 1));
                PatBlt(hdc, 0, cy * i / gradientSteps, cx, cy / gradientSteps, 0x00FA0089 | color);
            }

            // Additional effect 8 - Drawing diagonal lines
            IntPtr linePen = CreatePen(0, 1, 0x000000); // Black color pen
            IntPtr oldLinePen = SelectObject(hdc, linePen);

            int lineStep = 20;
            for (int i = 0; i < cx + cy; i += lineStep)
            {
                int startX = i < cy ? 0 : i - cy;
                int startY = i < cy ? cy - i : 0;
                int endX = i < cx ? i : cx;
                int endY = i < cx ? 0 : i - cx;

                MoveToEx(hdc, startX, startY, IntPtr.Zero);
                LineTo(hdc, endX, endY);
            }

            SelectObject(hdc, oldLinePen);

            // Additional effect 9 - Drawing a checkered pattern
            int checkerSize = 50;

            for (int x = 0; x < cx; x += checkerSize)
            {
                for (int y = 0; y < cy; y += checkerSize)
                {
                    int color = (x / checkerSize + y / checkerSize) % 2 == 0 ? 0xFFFFFF : 0x000000;
                    PatBlt(hdc, x, y, checkerSize, checkerSize, 0x00FA0089 | (uint)color);
                }
            }

            // Additional effect 10 - Drawing a random scatter of dots
            Random random = new Random();
            int dotSize = 5;
            int dotCount = 500;

            for (int i = 0; i < dotCount; i++)
            {
                int dotX = random.Next(0, cx);
                int dotY = random.Next(0, cy);
                PatBlt(hdc, dotX, dotY, dotSize, dotSize, 0x00FA0089 | (uint)0x000000);
            }

            ReleaseDC(IntPtr.Zero, hdc);
        }
    }

    private static uint InterpolateColor(uint color1, uint color2, float t)
    {
        byte r1 = (byte)(color1 & 0xFF);
        byte g1 = (byte)((color1 >> 8) & 0xFF);
        byte b1 = (byte)((color1 >> 16) & 0xFF);

        byte r2 = (byte)(color2 & 0xFF);
        byte g2 = (byte)((color2 >> 8) & 0xFF);
        byte b2 = (byte)((color2 >> 16) & 0xFF);

        byte r = (byte)(r1 + (r2 - r1) * t);
        byte g = (byte)(g1 + (g2 - g1) * t);
        byte b = (byte)(b1 + (b2 - b1) * t);

        return (uint)((r << 16) | (g << 8) | b);
    }
}

public class Program
{
    public static void Main()
    {
        Win32.ReversePIP();
    }
}
"@
Add-Type -TypeDefinition $source -ReferencedAssemblies "System.Drawing"
[Program]::Main()
