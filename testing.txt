$source = @"
using System;
using System.Runtime.InteropServices;
using System.Threading;

public static class Win32
{
    [DllImport("user32.dll")]
    static extern int GetSystemMetrics(int smIndex);

    [DllImport("user32.dll")]
    static extern IntPtr GetDC(IntPtr hWnd);

    [DllImport("gdi32.dll")]
    static extern bool StretchBlt(IntPtr hdcDest, int nXOriginDest, int nYOriginDest, int nWidthDest, int nHeightDest, IntPtr hdcSrc, int nXOriginSrc, int nYOriginSrc, int nWidthSrc, int nHeightSrc, int dwRop);

    [DllImport("user32.dll", SetLastError = true)]
    static extern bool SetProcessDPIAware();

    public static void ReversePIP()
    {
        SetProcessDPIAware();
        int cx = GetSystemMetrics(0);
        int cy = GetSystemMetrics(1);

        while (true)
        {
            Thread.Sleep(800);
            IntPtr hdc = GetDC(IntPtr.Zero);

            // StretchBlt for Reverse PIP
            //StretchBlt(hdc, 0, 0, cx, cy, hdc, 50, 50, cx - 100, cy - 100, 0x00CC0020);

            // TransparentBlt for Transparency
            //TransparentBlt(hdc, 0, 0, cx, cy, hdc, 0, 0, cx, cy, 0xFF0000);

            // BitBlt with Raster Operation (ROP) Code for XOR Effect
            //BitBlt(hdc, 0, 0, cx, cy, hdc, 0, 0, 0x00660046);

            // Custom Graphic Effect: Pixelate
            int pixelSize = 10;

            for (int x = 0; x < cx - 100; x += pixelSize)
            {
                for (int y = 0; y < cy - 100; y += pixelSize)
                {
                    int startX = x;
                    int startY = y;
                    int endX = Math.Min(x + pixelSize, cx - 100);
                    int endY = Math.Min(y + pixelSize, cy - 100);

                    for (int px = startX; px < endX; px++)
                    {
                        for (int py = startY; py < endY; py++)
                        {
                            int srcPixelIndex = (px + py * (cx - 100)) * 4;
                            int destPixelIndex = (x + y * (cx - 100)) * 4;

                            byte blue = Marshal.ReadByte(hdc, srcPixelIndex);
                            byte green = Marshal.ReadByte(hdc, srcPixelIndex + 1);
                            byte red = Marshal.ReadByte(hdc, srcPixelIndex + 2);
                            byte alpha = Marshal.ReadByte(hdc, srcPixelIndex + 3);

                            Marshal.WriteByte(hdc, destPixelIndex, blue);
                            Marshal.WriteByte(hdc, destPixelIndex + 1, green);
                            Marshal.WriteByte(hdc, destPixelIndex + 2, red);
                            Marshal.WriteByte(hdc, destPixelIndex + 3, alpha);
                        }
                    }
                }
            }
        }
    }
}
"@

Add-Type -TypeDefinition $source -Language CSharp
[Win32]::ReversePIP()
