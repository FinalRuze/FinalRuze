$source = @"
using System;
using System.Runtime.InteropServices;
using System.Threading;

public static class Win32
{
    [DllImport("user32.dll")]
    static extern int GetSystemMetrics(int smIndex);

    [DllImport("user32.dll")]
    static extern IntPtr GetDC(IntPtr hWnd);

    [DllImport("gdi32.dll")]
    static extern bool StretchBlt(IntPtr hdcDest, int nXOriginDest, int nYOriginDest, int nWidthDest, int nHeightDest, IntPtr hdcSrc, int nXOriginSrc, int nYOriginSrc, int nWidthSrc, int nHeightSrc, int dwRop);

    [DllImport("user32.dll", SetLastError = true)]
    static extern bool SetProcessDPIAware();

    [DllImport("gdi32.dll")]
    static extern IntPtr CreatePen(int fnPenStyle, int nWidth, uint crColor);

    [DllImport("gdi32.dll")]
    static extern IntPtr SelectObject(IntPtr hdc, IntPtr hgdiobj);

    [DllImport("gdi32.dll")]
    static extern bool Rectangle(IntPtr hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect);

    [DllImport("gdi32.dll")]
    static extern bool Polygon(IntPtr hdc, int[] points, int nCount);

    [DllImport("gdi32.dll")]
    static extern bool Ellipse(IntPtr hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect);

    [DllImport("gdi32.dll")]
    static extern bool RoundRect(IntPtr hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nWidth, int nHeight);

    [DllImport("gdi32.dll")]
    static extern bool BitBlt(IntPtr hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, IntPtr hdcSrc, int nXSrc, int nYSrc, uint dwRop);

    [DllImport("gdi32.dll")]
    static extern bool PatBlt(IntPtr hdc, int nXLeft, int nYLeft, int nWidth, int nHeight, uint dwRop);

    public static void ReversePIP()
    {
        SetProcessDPIAware();
        int cx = GetSystemMetrics(0);
        int cy = GetSystemMetrics(1);

        while (true)
        {
            Thread.Sleep(100);
            IntPtr hdc = GetDC(IntPtr.Zero);

            // Original effect - StretchBlt
            StretchBlt(hdc, 0, 0, cx, cy, hdc, 50, 50, cx - 100, cy - 100, 0x00CC0020);

            // Additional effect 1 - Drawing rectangles
            IntPtr pen = CreatePen(0, 5, 0x000000); // Black color pen
            IntPtr oldPen = SelectObject(hdc, pen);

            Rectangle(hdc, 100, 100, cx - 100, cy - 100);
            Rectangle(hdc, 200, 200, cx - 200, cy - 200);

            SelectObject(hdc, oldPen);

            // Additional effect 2 - Drawing multiple hexagons to fill the screen
            int hexagonSize = 100;
            int hexagonMargin = 20;
            int hexagonRowCount = (cy - 2 * hexagonMargin) / (hexagonSize + hexagonMargin);
            int hexagonColumnCount = (cx - 2 * hexagonMargin) / (hexagonSize + hexagonMargin);
            int totalHexagons = hexagonRowCount * hexagonColumnCount;

int[] hexagonXPositions = new int[totalHexagons];
int[] hexagonYPositions = new int[totalHexagons];

int startX = hexagonMargin;
int startY = hexagonMargin;

for (int i = 0; i < totalHexagons; i++)
{
    int row = i / hexagonColumnCount;
    int column = i % hexagonColumnCount;

    int hexagonX = startX + column * (hexagonSize + hexagonMargin);
    int hexagonY = startY + row * (hexagonSize + hexagonMargin);

    hexagonXPositions[i] = hexagonX;
    hexagonYPositions[i] = hexagonY;

    int[] hexagonPoints = new int[]
    {
        hexagonX + hexagonSize / 2, hexagonY,
        hexagonX + hexagonSize, hexagonY + hexagonSize / 3,
        hexagonX + hexagonSize, hexagonY + 2 * hexagonSize / 3,
        hexagonX + hexagonSize / 2, hexagonY + hexagonSize,
        hexagonX, hexagonY + 2 * hexagonSize / 3,
        hexagonX, hexagonY + hexagonSize / 3
    };
    Polygon(hdc, hexagonPoints, hexagonPoints.Length / 2);
}

// Additional effect 3 - Drawing ellipses
int ellipseSize = 100;
int ellipseMargin = 50;
int ellipseRowCount = (cy - 2 * ellipseMargin) / (ellipseSize + ellipseMargin);
int ellipseColumnCount = (cx - 2 * ellipseMargin) / (ellipseSize + ellipseMargin);

for (int row = 0; row < ellipseRowCount; row++)
{
    for (int column = 0; column < ellipseColumnCount; column++)
    {
        int ellipseX = ellipseMargin + column * (ellipseSize + ellipseMargin);
        int ellipseY = ellipseMargin + row * (ellipseSize + ellipseMargin);

        Ellipse(hdc, ellipseX, ellipseY, ellipseX + ellipseSize, ellipseY + ellipseSize);
    }
}

// Additional effect 4 - Drawing rounded rectangles
int roundedRectWidth = 200;
int roundedRectHeight = 100;
int roundedRectMargin = 50;
int roundedRectRowCount = (cy - 2 * roundedRectMargin) / (roundedRectHeight + roundedRectMargin);
int roundedRectColumnCount = (cx - 2 * roundedRectMargin) / (roundedRectWidth + roundedRectMargin);

for (int row = 0; row < roundedRectRowCount; row++)
{
    for (int column = 0; column < roundedRectColumnCount; column++)
    {
        int roundedRectX = roundedRectMargin + column * (roundedRectWidth + roundedRectMargin);
        int roundedRectY = roundedRectMargin + row * (roundedRectHeight + roundedRectMargin);

        RoundRect(hdc, roundedRectX, roundedRectY, roundedRectX + roundedRectWidth, roundedRectY + roundedRectHeight, 20, 20);
    }
}

// Additional effect 5 - Inverting colors
BitBlt(hdc, 0, 0, cx, cy, hdc, 0, 0, 0x00550009);

// Delay for 1 second
Thread.Sleep(1000);

// Additional effect 6 - Cursed pattern using PatBlt
int patternSize = 50;
int patternRowCount = (cy - patternSize) / patternSize;
int patternColumnCount = (cx - patternSize) / patternSize;

for (int row = 0; row < patternRowCount; row++)
{
    for (int column = 0; column < patternColumnCount; column++)
    {
        int patternX = patternSize * column;
        int patternY = patternSize * row;

        // Alternate between BLACKNESS and WHITENESS
        if ((row + column) % 2 == 0)
            PatBlt(hdc, patternX, patternY, patternSize, patternSize, 0x000F0000); // BLACKNESS
        else
            PatBlt(hdc, patternX, patternY, patternSize, patternSize, 0x00FF0062); // WHITENESS
    }
}

// Delay for 0.1 second
Thread.Sleep(100);

// Additional effect 7 - Cursed effect using StretchBlt with inverted coordinates
StretchBlt(hdc, cx, cy, -cx, -cy, hdc, 0, 0, cx, cy, 0x00CC0020);

// Delay for 1 second
Thread.Sleep(1000);

// Additional effect 8 - Cursed effect using BitBlt with random positions
int randomX = 0;
int randomY = 0;
int randomWidth = 0;
int randomHeight = 0;

Random random = new Random();

for (int i = 0; i < 200; i++)
{
    randomX = random.Next(0, cx);
    randomY = random.Next(0, cy);
    randomWidth = random.Next(0, cx - randomX);
    randomHeight = random.Next(0, cy - randomY);

    BitBlt(hdc, randomX, randomY, randomWidth, randomHeight, hdc, randomX, randomY, 0x00BB0226);

    // Delay for 10 milliseconds
    Thread.Sleep(10);
}

// Additional effect 9 - Cursed effect using custom GDI operation (CURSED OPERATION)
// Implement your own custom GDI operation here. For example, let's draw randomly sized and positioned shapes.
int numShapes = 500; // Number of shapes to draw
int maxShapeSize = Math.Min(cx, cy); // Maximum shape size

for (int i = 0; i < numShapes; i++)
{
    int shapeSize = random.Next(50, maxShapeSize); // Random shape size
    int shapeX = random.Next(0, cx - shapeSize); // Random X position
    int shapeY = random.Next(0, cy - shapeSize); // Random Y position

    int shapeType = random.Next(0, 6); // Random shape type (0: Rectangle, 1: Ellipse, 2: Rounded Rectangle, 3: Triangle, 4: Trapezoid, 5: Diamond)

    switch (shapeType)
    {
        case 0: // Rectangle
            Rectangle(hdc, shapeX, shapeY, shapeX + shapeSize, shapeY + shapeSize);
            break;
        case 1: // Ellipse
            Ellipse(hdc, shapeX, shapeY, shapeX + shapeSize, shapeY + shapeSize);
            break;
        case 2: // Rounded Rectangle
            int cornerRadius = random.Next(0, 50); // Random corner radius
            RoundRect(hdc, shapeX, shapeY, shapeX + shapeSize, shapeY + shapeSize, cornerRadius, cornerRadius);
            break;
        case 3: // Triangle
            int[] trianglePoints = new int[]
            {
                shapeX, shapeY + shapeSize,
                shapeX + shapeSize / 2, shapeY,
                shapeX + shapeSize, shapeY + shapeSize
            };
            Polygon(hdc, trianglePoints, trianglePoints.Length / 2);
            break;
        case 4: // Trapezoid
            int topWidth = random.Next(0, shapeSize); // Random top width
            int bottomWidth = random.Next(0, shapeSize); // Random bottom width
            int trapezoidHeight = random.Next(0, shapeSize); // Random trapezoid height

            int[] trapezoidPoints = new int[]
            {
                shapeX, shapeY + trapezoidHeight,
                shapeX + topWidth, shapeY,
                shapeX + shapeSize - bottomWidth, shapeY,
                shapeX + shapeSize, shapeY + trapezoidHeight
            };
            Polygon(hdc, trapezoidPoints, trapezoidPoints.Length / 2);
            break;
        case 5: // Diamond
            int[] diamondPoints = new int[]
            {
                shapeX + shapeSize / 2, shapeY,
                shapeX + shapeSize, shapeY + shapeSize / 2,
                shapeX + shapeSize / 2, shapeY + shapeSize,
                shapeX, shapeY + shapeSize / 2
            };
            Polygon(hdc, diamondPoints, diamondPoints.Length / 2);
            break;
    }

    // Delay for 0.1 seconds
    Thread.Sleep(10);
}

// Delay for 0.1 second
Thread.Sleep(10);

// Additional effect 10 - Cursed effect: Screen Glitch
int glitchCount = 500; // Number of glitches to create

for (int i = 0; i < glitchCount; i++)
{
    int glitchWidth = random.Next(100, 300); // Random glitch width
    int glitchHeight = random.Next(100, 300); // Random glitch height
    int glitchX = random.Next(0, cx - glitchWidth); // Random X position
    int glitchY = random.Next(0, cy - glitchHeight); // Random Y position

    StretchBlt(hdc, glitchX, glitchY, glitchWidth, glitchHeight, hdc, glitchX + random.Next(-50, 50), glitchY + random.Next(-50, 50), glitchWidth, glitchHeight, 0x00CC0020);

    // Delay for 100 milliseconds
    Thread.Sleep(100);
}

// Additional effect 11 - Cursed effect: Randomized BitBlt
for (int i = 0; i < 200; i++)
{
    int sourceX = random.Next(0, cx);
    int sourceY = random.Next(0, cy);
    int destinationX = random.Next(0, cx);
    int destinationY = random.Next(0, cy);
    int width = random.Next(0, cx - destinationX);
    int height = random.Next(0, cy - destinationY);

    BitBlt(hdc, destinationX, destinationY, width, height, hdc, sourceX, sourceY, 0x00BB0226);

    // Delay for 200 milliseconds
    Thread.Sleep(200);
}

// Additional effect 12 - Cursed effect: Shaking screen
int shakeAmount = 50; // Amount of shaking

for (int i = 0; i < 200; i++)
{
    StretchBlt(hdc, random.Next(-shakeAmount, shakeAmount), random.Next(-shakeAmount, shakeAmount), cx, cy, hdc, 0, 0, cx, cy, 0x00CC0020);

    // Delay for 200 milliseconds
    Thread.Sleep(200);
}

// Additional effect 13 - Cursed effect: Distorted StretchBlt
int distortionAmount = 500; // Amount of distortion to apply

for (int i = 0; i < 200; i++)
{
    StretchBlt(hdc, 0, 0, cx, cy, hdc, random.Next(-distortionAmount, distortionAmount), random.Next(-distortionAmount, distortionAmount), cx, cy, 0x00CC0020);

    // Delay for 200 milliseconds
    Thread.Sleep(200);
}

// Additional effect 14 - Cursed effect: Randomized color inversion
for (int i = 0; i < 200; i++)
{
    int inversionX = random.Next(0, cx);
    int inversionY = random.Next(0, cy);
    int inversionWidth = random.Next(0, cx - inversionX);
    int inversionHeight = random.Next(0, cy - inversionY);

    BitBlt(hdc, inversionX, inversionY, inversionWidth, inversionHeight, hdc, inversionX, inversionY, 0x00550009);

    // Delay for 200 milliseconds
    Thread.Sleep(200);
}

// Additional effect 15 - Cursed effect: Warped StretchBlt
int warpAmount = 50; // Amount of warping

for (int i = 0; i < 200; i++)
{
    StretchBlt(hdc, 0, 0, cx, cy, hdc, random.Next(-warpAmount, warpAmount), random.Next(-warpAmount, warpAmount), cx + random.Next(-warpAmount, warpAmount), cy + random.Next(-warpAmount, warpAmount), 0x00CC0020);

    // Delay for 200 milliseconds
    Thread.Sleep(200);
}

// Additional effect 16 - Cursed effect: Randomized StretchBlt
for (int i = 0; i < 200; i++)
{
    int sourceX = random.Next(0, cx);
    int sourceY = random.Next(0, cy);
    int sourceWidth = random.Next(0, cx - sourceX);
    int sourceHeight = random.Next(0, cy - sourceY);
    int destinationX = random.Next(0, cx);
    int destinationY = random.Next(0, cy);
    int destinationWidth = random.Next(0, cx - destinationX);
    int destinationHeight = random.Next(0, cy - destinationY);

    StretchBlt(hdc, destinationX, destinationY, destinationWidth, destinationHeight, hdc, sourceX, sourceY, sourceWidth, sourceHeight, 0x00CC0020);

    // Delay for 200 milliseconds
    Thread.Sleep(200);
}

// Additional effect 17 - Cursed effect: Scrambled StretchBlt
for (int i = 0; i < 200; i++)
{
    int scrambleAmount = 500; // Amount to scramble the image

    for (int x = 0; x < cx; x += scrambleAmount)
    {
        for (int y = 0; y < cy; y += scrambleAmount)
        {
            int sourceX = random.Next(x, x + scrambleAmount);
            int sourceY = random.Next(y, y + scrambleAmount);
            int destinationX = random.Next(x, x + scrambleAmount);
            int destinationY = random.Next(y, y + scrambleAmount);

            BitBlt(hdc, destinationX, destinationY, scrambleAmount, scrambleAmount, hdc, sourceX, sourceY, 0x00CC0020);
        }
    }

    // Delay for 200 milliseconds
    Thread.Sleep(200);
}

// Additional effect 18 - Cursed effect: Randomized Ellipse
for (int i = 0; i < 200; i++)
{
    int left = random.Next(0, cx);
    int top = random.Next(0, cy);
    int right = random.Next(left, cx);
    int bottom = random.Next(top, cy);

    Ellipse(hdc, left, top, right, bottom);

    // Delay for 200 milliseconds
    Thread.Sleep(200);
}

// Additional effect 19 - Cursed effect: Randomized BitBlt
for (int i = 0; i < 200; i++)
{
    int sourceX = random.Next(0, cx);
    int sourceY = random.Next(0, cy);
    int sourceWidth = random.Next(0, cx - sourceX);
    int sourceHeight = random.Next(0, cy - sourceY);
    int destinationX = random.Next(0, cx);
    int destinationY = random.Next(0, cy);

    BitBlt(hdc, destinationX, destinationY, sourceWidth, sourceHeight, hdc, sourceX, sourceY, 0x00CC0020);

    // Delay for 200 milliseconds
    Thread.Sleep(200);
}

// Additional effect 20 - Cursed effect: Warped BitBlt
for (int i = 0; i < 10; i++)
{
    int sourceX = random.Next(0, cx);
    int sourceY = random.Next(0, cy);
    int sourceWidth = random.Next(0, cx - sourceX);
    int sourceHeight = random.Next(0, cy - sourceY);
    int destinationX = random.Next(0, cx);
    int destinationY = random.Next(0, cy);

    POINT[] points = new POINT[3];
    points[0].X = destinationX;
    points[0].Y = destinationY;
    points[1].X = random.Next(destinationX, destinationX + sourceWidth);
    points[1].Y = random.Next(destinationY, destinationY + sourceHeight);
    points[2].X = destinationX + sourceWidth;
    points[2].Y = destinationY + sourceHeight;

    PolyBlt(hdc, points, hdc, sourceX, sourceY, sourceWidth, sourceHeight, 0x00CC0020);

    // Delay for 200 milliseconds
    Thread.Sleep(200);
}
        }
    }
}
"@
Add-Type -TypeDefinition $source -Language CSharp
[Win32]::ReversePIP()
